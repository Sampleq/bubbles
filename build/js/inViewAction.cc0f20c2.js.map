{"version":3,"sources":["scripts/inViewAction.js"],"names":["call","document","querySelector","cballs","querySelectorAll","moveOnceC","arr","x","y","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","style","transform","Math","random","err","e","f","cmocid","fmocid","ftr","fballs","moveOnceF","_step2","_iterator2","startAnim","setInterval","stopAnim","clearInterval","observer","IntersectionObserver","entries","_step3","_iterator3","entry","isIntersecting","target","observe"],"mappings":"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","file":"inViewAction.cc0f20c2.js","sourceRoot":"../../src","sourcesContent":["// \n// Анимация движения шаров для секций Call и Footer при их нахождении в поле видимости (во viewport)\n// \n\nconst call = document.querySelector('.call');\nconst cballs = document.querySelectorAll('.call__ball');\n\nfunction moveOnceC(arr, x, y) {\n    for (let el of arr) {\n        el.style.transform = 'translate(' + (Math.random() * (2 * x) - 1.2 * x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.2 + Math.random() * 1.5) + ')';\n    }\n}\n\n// ???\n// Создаём новую сущность класса IntersectionObserver и передаём в коллбек функцию которая вызывается при изменении пересечения (с вьюпортом). \n// Коллбек функция получает массив объектов IntersectionObserverEntry каждый из которых описывает пересечение целевого элемента с вьюпортом. \n// циклом или иным способом проходимся (обращаемся) к каждому элементу  и проверяем истинность isIntersecting ( is true) - что соответствует видимости элемента. Описываем необходимые действия для видимого элемента\n\n// Works OK!!\n// let mocid\n\n// const observer = new IntersectionObserver(\n//     function (entries) {\n//         // console.log(entries);\n//         // массив entries можно обойти циклами for или .forEach . Если один элемент в массиве - можно обратиться к нему просто по индексу ([0]). Если элементов - несколько - к 1, и т.д.. обратиться по индексу не получается\n//         // if (entries[0].isIntersecting === true) { можно не писать явно  === true и записать короче:\n\n//         if (entries[0].isIntersecting) {\n//             // call.style.background = 'red';\n//             moveOnceC(cballs, 60, 20);\n//             mocid = setInterval(moveOnceC, 4000, cballs, 60, 10);\n//             console.log('start func looped');\n//             console.log(entries[0]);\n//         }\n//         else {\n//             clearInterval(mocid);\n//             console.log('section \"call\" is not in a view');\n//         }\n//     });\n\n// observer.observe(call);\n// Works OK!!\n\n\n// добавим объекты в футере для анимации \nconst ftr = document.querySelector('.footer');\nconst fballs = document.querySelectorAll('.footer__ball');\n\nfunction moveOnceF(arr, x, y) {\n    for (let el of arr) {\n        el.style.transform = 'translate(' + (Math.random() * (2 * x) - (1.2 * x)) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.4 + Math.random() * 1.1) + ')';\n    }\n}\n\n//  задаём переменные для хранения идентификаторов регулярного запуска\n    let cmocid\n    let fmocid\n\n    // создадим методы каждому объекту. Называем одинаково, чтоб потом можно было обратиться в цикле. (но содержание  методов у каждого объекта  - своё )\n    call.startAnim = () => {\n        moveOnceC(cballs, 60, 20);\n            cmocid = setInterval(moveOnceC, 4000, cballs, 60, 10);\n    };\n    call.stopAnim = () => {\n        clearInterval(cmocid);\n    }\n\n    ftr.startAnim = () => {\n        moveOnceF(fballs, 15, 5);\n            fmocid = setInterval(moveOnceF, 4000, fballs, 15, 5);\n    };\n    ftr.stopAnim = () => {\n        clearInterval(fmocid);\n    }\n\n\nconst observer = new IntersectionObserver(\n    function (entries) {\n\n        for (let entry of entries) {\n            if (entry.isIntersecting) {\n            // entry.target.style.background = 'red';\n            entry.target.startAnim();\n            // console.log(entry);\n            // console.log('section \"is in a view');\n        }\n        else {\n            entry.target.stopAnim();\n            // console.log('section is not in a view');\n        }\n        }\n    });\n\n    // объекты для наблюдения добавляем после объявления самого const observer \n    observer.observe(call);\n    observer.observe(ftr);\n\n"]}