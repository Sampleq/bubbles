{"version":3,"sources":["scripts/moveBalls.js"],"names":["mbId","video","document","getElementById","vballs","querySelectorAll","moveOnce","arr","x","y","_step","_iterator","_createForOfIteratorHelper","s","n","done","el","value","window","innerWidth","style","transform","Math","random","err","e","f","console","log","moveBalls","section","setInterval","matchMedia","matches","addEventListener","stopBalls","once","clearInterval","_step2","_iterator2","_loop","transition","setTimeout","video2","vballsYtb","btn1","querySelector","btn2","stopBallsByBtn","mbIdAftMod","_step3","_iterator3","_loop2","vcont","btn","modal","videoJS","onclick","display","play","event","target","pause","classList","remove","add","animationPlayState","videoLocal","moveOnceAftMod","_step4","_iterator4","currentBalls","observerMob","IntersectionObserver","entries","forEach","entry","isIntersecting","observe"],"mappings":"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","file":"moveBalls.132a5910.js","sourceRoot":"../../src","sourcesContent":["// \n// Анимация движения шаров для секции Video - при наведении на неё указателя мыши\n// \n\n\n// if (window.innerWidth >= 1024) {\n\nconst video = document.getElementById('video');\nconst vballs = document.querySelectorAll('.video__ball');\n\n// задаём функцию для передвижения объектов массива на заданное расстояние (в rem)\n// Math.floor() для округления до меньшего целого - можно не использовать\nfunction moveOnce(arr, x, y) {\n    for (let el of arr) {\n        if (window.innerWidth < 768) {\n            el.style.transform = 'translate(' + (Math.random() * (2 * x) - x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.2 + Math.random() * 0.5) + ')';\n        } else {\n            el.style.transform = 'translate(' + (Math.random() * (2 * x) - x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.4 + Math.random() * 1.1) + ')';\n        }\n    }\n    console.log('moveOnce(arr, x, y)')\n}\n\n// задаём переменную в которую будем сохранять \"идентификатор для регулярного запуска функции\" moveBalls - идентификатор возвращает функция setInterval() -, чтобы потом можно было остановить её повторяющееся выполнение через clearInterval(). При вызове clearInterval() браузер найдёт таймер (из список активных таймеров браузера) по идентификатору и уберёт его из списка - повторение функции moveBalls прекратится.\nlet mbId;\n\n// Создаём функцию с однократным запуском перемещения элементов и регулярным её перезапуском каждые 4000мс\nfunction moveBalls(section, arr, x, y) {\n    moveOnce(arr, x, y);\n    mbId = setInterval(moveOnce, 4000, arr, x, y);\n\n    // вешаем листнер на остановку анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится. ({ once: true } можно даже использовать с анонимными функциями и не нужно будет очищать обработчик  - он удалится автоматически.)\n    //  вешаем листнер только если устройства \"мышь\".\n    if (window.matchMedia('(hover: hover)').matches || window.matchMedia('(pointer: fine)').matches) {\n        section.addEventListener('mouseleave', () => { stopBalls(section, arr) }, { once: true });\n    }\n}\n\n// Создаём функцию, которая остановит регулярный перезапуск moveOnce. - Функции clearInterval() передаём аргументом идентификатор регулярного перезапуска функции - идентификатор, который возвращает функция setInterval() - мы его сохранили в переменную mbId\nfunction stopBalls(section, arr) {\n    // прервали повторение выполнения функции перемещения элементов moveOnce\n    clearInterval(mbId);\n    console.log(\"stopBalls runs and clearInterval(mbId)\")\n\n    for (let el of arr) {\n        //  зададём продолжительность transition 0.5s для  элементов - чтобы плавно но быстро вернуть их в начальное место.\n        el.style.transition = 'all 0.5s linear';\n\n        //  для каждой ширины экрана возвращаем начальные свойства transform  для элементов\n        if (window.innerWidth < 425) {\n            el.style.transform = 'translate(0, 0) scale(0.35)';\n        } else {\n            if (window.innerWidth < 768) {\n                el.style.transform = 'translate(0, 0) scale(0.5)';\n            } else {\n                if (window.innerWidth < 1024) {\n                    el.style.transform = 'translate(0, 0) scale(0.75)';\n                } else {\n\n                    el.style.transform = 'translate(0, 0)';\n                }\n            }\n        }\n        // после выполнения остального js кода - возвращаем изначальное значение transition = 12s для всех элементов - чтоб при следующих запусках перемещений элементы двигались с изначально заданной скоростью.\n        //  Хотя transition =  12s присваивается элементам ещё в момент анимации с transition = 0.5s  - анимация всё равно продолжается время 0.5s - как это было указано во время начала анимации\n        setTimeout(\n            () => {\n                el.style.transition = 'all 12s linear';\n            }\n            , 16)\n    }\n\n    // вешаем листнер на старт анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится.\n    //  вешаем листнер только если устройства ввода \"мышь\".\n    if (window.matchMedia('(hover: hover)').matches || window.matchMedia('(pointer: fine)').matches) {\n        section.addEventListener('mouseenter', () => { moveBalls(section, arr, 80, 40) }, { once: true });\n    }\n}\n\n// // вешаем первоначальный (после загрузки страницы) листнер на старт анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится. (убрать листнер  с функцией с аргументами  через removeEventListener - не получается, внутрь безымянной функции-обёртки класть не стал)\n// вешаем после проверки что устройство поддерживает устройство ввода \"мышь\" - строка ~250\n// video.addEventListener('mouseenter', () => { moveBalls(video, vballs, 80, 40) }, { once: true });\n\n// не экономя память - просто вешаем листнеры\n// video.addEventListener('mouseenter', () => { moveBalls(vballs, 80, 40) });\n// вешаем листнер для остановки анимации.\n// video.addEventListener('mouseleave', () => { stopBalls(vballs) });\n\n// добавляем анимацию на второй блок с видео с id=\"video2\"\n\nconst video2 = document.getElementById('video2');\nconst vballsYtb = document.querySelectorAll('.video__ball_ytb');\n\n// вешаем после проверки что устройство поддерживает устройство ввода \"мышь\" - строка ~250\n// video2.addEventListener('mouseenter', () => { moveBalls(video2, vballsYtb, 80, 40) }, { once: true })\n\n\n\n// останавливаем анимацию движения шаров после нажатия  на кнопку воспроизведения видео\nconst btn1 = document.querySelector('.video__btn');\nconst btn2 = document.querySelector('.video__btn_2');\n\nfunction stopBallsByBtn(arr) {\n    clearInterval(mbId);\n    clearInterval(mbIdAftMod); //останавливаем движение запущенное закрытием модального окна\n    for (let el of arr) {\n        el.style.transition = 'all 0.5s linear';\n        if (window.innerWidth < 425) {\n            el.style.transform = 'translate(0, 0) scale(0.35)';\n        } else {\n            if (window.innerWidth < 768) {\n                el.style.transform = 'translate(0, 0) scale(0.5)';\n            } else {\n                if (window.innerWidth < 1024) {\n                    el.style.transform = 'translate(0, 0) scale(0.75)';\n                } else {\n\n                    el.style.transform = 'translate(0, 0)';\n                }\n            }\n        };\n        setTimeout(() => {\n            el.style.transition = 'all 12s linear';\n        }, 16)\n    };\n}\n\nbtn1.addEventListener('click', () => {\n    stopBallsByBtn(vballs);\n});\nbtn2.addEventListener('click', () => {\n    stopBallsByBtn(vballsYtb);\n});\n\n// }\n// , { once: true }\n\n\n// \n// from file ShowVideo.js\nconst vcont = document.querySelector('.video-cnt');\nconst btn = document.querySelector('.video__btn');\nconst modal = document.querySelector('.video__mov');\nconst videoJS = document.querySelector('.video__clip');\n\nbtn.onclick = () => {\n    // vcont.style.display = 'none';\n    // modal.classList.add('video__mov_in')\n    modal.style.display = 'flex';\n    setTimeout(() => {\n        videoJS.play();\n    }, 600);\n}\n\nlet mbIdAftMod;\n\n\nmodal.onclick = (event) => {\n    if (event.target === modal) {\n        videoJS.pause();  // - !! из-за этого не работает закрытие видео с youtube (во frame-е).\n        // .stop() - такого метода нет. video.stop();\n        // video.style.display = 'none';\n        videoJS.classList.remove('video__clip_in');\n        videoJS.classList.add('video__clip_out');\n\n        // сначала скрываем элемент, а затем показываем для срабатывания анимации. Можно также через js запустить старт анимации (.animationPlayState = 'running') после смены классов с анимацией\n        // setTimeout(() => {\n        //     video.style.display = 'block';\n        // }, 0);\n\n        videoJS.style.animationPlayState = 'running';\n        // нет необхдимости скрывать показывать элемент для запуска анимации - запускаем анимацию с помощью css свойства animation-play-state: running; (в JS - .animationPlayState = 'running')\n\n        // возвращаем нужные классы с анимацией и скрываем элемент родитель (контейнер). задержка 0.5 секунды - точно как продолжительность анимации\n        setTimeout(() => {\n            videoJS.classList.remove('video__clip_out');\n            videoJS.classList.add('video__clip_in');\n            modal.style.display = 'none';\n        }, 500);\n\n\n\n\n        // возобновляем движение после закрытия модала. Т.к. пишем в разных файлах - некоторые переменые с объектами и части функций задаём и пишем заново и/или повторно \n        const videoLocal = document.getElementById('video');\n        const vballs = document.querySelectorAll('.video__ball');\n        function moveOnceAftMod(arr, x, y) {\n            for (let el of arr) {\n                if (window.innerWidth < 768) {\n                    el.style.transform = 'translate(' + (Math.random() * (2 * x) - x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.2 + Math.random() * 0.5) + ')';\n                } else {\n                    el.style.transform = 'translate(' + (Math.random() * (2 * x) - x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.4 + Math.random() * 1.1) + ')';\n                }\n            }\n            console.log('moveOnceAftMod')\n        }\n\n        function moveBallsAftMod(section, arr, x, y) {\n            setTimeout(() => {\n                moveOnceAftMod(arr, x, y);\n            }, 500);\n            mbIdAftMod = setInterval(moveOnceAftMod, 4000, arr, x, y);\n\n            // вешаем после проверки что устройство поддерживает устройство ввода \"мышь\"\n            if (window.matchMedia('(hover: hover)').matches || window.matchMedia('(pointer: fine)').matches) {\n                section.addEventListener('mouseleave', () => { stopBallsAftMod(section, arr) }, { once: true });\n            }\n        }\n\n        function stopBallsAftMod(section, arr) {\n            clearInterval(mbIdAftMod);\n            console.log(\"stopBallsAftMod runs and clearInterval(mbIdAftMod)\")\n\n        }\n\n\n        moveBallsAftMod(videoLocal, vballs, 80, 40);\n\n\n    }\n\n}\n\n\n\n// стартуем движение шаров при попадании в область видимости на мобильных\n\n// https://stackoverflow.com/questions/56324813/how-to-detect-touch-device-in-2019\n\n// function isTouchDevice() {\n//     return (('ontouchstart' in window) ||\n//        (navigator.maxTouchPoints > 0) ||\n//        (navigator.msMaxTouchPoints > 0));\n//   }\n\n// // .window перед matchMedia() - не обязательно\n// if (matchMedia('(hover: hover)').matches) {\n//     console.log(\"matchMedia('(hover: hover)')\");\n// }\n\n// if (window.matchMedia('(pointer: coarse)').matches) {\n//     // touchscreen\n\n//     // @media(hover: none) and(pointer: coarse) {\n//     //     /* touchscreens */\n//     // }\n//     // @media(hover: none) and(pointer: fine) {\n//     //     /* stylus */\n//     // }\n//     // @media(hover: hover) and(pointer: coarse) {\n//     //     /* controllers */\n//     // }\n//     // @media(hover: hover) and(pointer: fine) {\n//     //     /* mouse or touchpad */\n//     // }\n// }\n\n// проверяем что устройство не поддерживает устройство ввода \"мышь\" а тачи и т.д.\nif (window.matchMedia('(hover: none)').matches || window.matchMedia('(pointer: coarse)').matches) {\n\n    video.currentBalls = vballs;\n    // console.log(video.currentBalls);\n    video2.currentBalls = vballsYtb;\n    // console.log(video2.currentBalls);\n\n    const observerMob = new IntersectionObserver(\n        function (entries) {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting === true) {\n\n                    // глючило и запускало moveBalls когда секция уже была в области видимости - чтобы точно избежать такого поведения - оставляем принудительную остановку анимации \n                    // stopBalls(entry.target, entry.target.currentBalls)\n                    // console.log(entry.target);\n                    // console.log('stopBalls()');\n\n                    // чтобы успело примениться transition к шарикам (entry.target.currentBalls)\n                    setTimeout(() => {\n                        moveBalls(section = null, entry.target.currentBalls, 80, 40)\n\n                        console.log(entry.target);\n                        console.log('start moveBalls()');\n                    }, 33);\n\n                } else {\n                    stopBalls(section = null, entry.target.currentBalls);\n\n                    clearInterval(mbIdAftMod); //останавливаем движение запущенное закрытием модального окна (если оно было открыто)\n\n                    console.log(entry.target);\n                    console.log('stopBalls()');\n                    console.log('clearInterval(mbIdAftMod)');\n\n                }\n            }\n            )\n        }\n    )\n\n\n    observerMob.observe(video);\n    observerMob.observe(video2);\n}\nelse { // вешаем первоначальный (после загрузки страницы) листнер на старт анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится. (убрать листнер  с функцией с аргументами  через removeEventListener - не получается, внутрь безымянной функции-обёртки класть не стал)\n    video.addEventListener('mouseenter', () => { moveBalls(video, vballs, 80, 40) }, { once: true });\n    video2.addEventListener('mouseenter', () => { moveBalls(video2, vballsYtb, 80, 40) }, { once: true });\n}"]}