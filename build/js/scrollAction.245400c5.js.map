{"version":3,"sources":["scripts/scrollAction.js"],"names":["window","innerWidth","vid","document","getElementById","voval","querySelector","vid2","vovalYtb","moveOval1","style","transform","scrollY","moveOval2","scrllstart","addEventListener","scrllstop","removeEventListener","observer5","IntersectionObserver","entries","forEach","entry","isIntersecting","target","observe"],"mappings":";AAIA,GAAIA,OAAOC,WAAa,KAAM,CAC1B,IAAMC,EAAMC,SAASC,eAAe,SAC9BC,EAAQF,SAASG,cAAc,qBAK/BC,EAAOJ,SAASC,eAAe,UAC/BI,EAAWL,SAASC,eAAe,wBAIzC,SAASK,IACDT,OAAOC,WAAa,KACpBI,EAAMK,MAAMC,UAAY,cAAwC,IAAjBX,OAAOY,QAAZ,IAA+B,QAAU,GAAuB,IAAjBZ,OAAOY,SAAmB,OAEnHP,EAAMK,MAAMC,UAAY,cAAwC,IAAjBX,OAAOY,QAAZ,IAA+B,QAAU,GAAuB,IAAjBZ,OAAOY,SAAmB,OAW3H,SAASC,IACDb,OAAOC,WAAa,KACpBO,EAASE,MAAMC,UAAY,cAAyC,IAAjBX,OAAOY,QAAb,KAAgC,QAAU,GAAuB,IAAjBZ,OAAOY,SAAmB,OAEvHJ,EAASE,MAAMC,UAAY,cAAyC,IAAjBX,OAAOY,QAAb,KAAgC,QAAU,GAAuB,IAAjBZ,OAAOY,SAAmB,OAZ/HV,EAAIY,WAAa,WACbX,SAASY,iBAAiB,SAAUN,IAExCP,EAAIc,UAAY,WACZb,SAASc,oBAAoB,SAAUR,IAW3CF,EAAKO,WAAa,WACdX,SAASY,iBAAiB,SAAUF,IAExCN,EAAKS,UAAY,WACbb,SAASc,oBAAoB,SAAUJ,IAI3C,IAAMK,EAAY,IAAIC,qBAAqB,SAACC,GACxCA,EAAQC,QAAQ,SAACC,IACgB,IAAzBA,EAAMC,eACND,EAAME,OAAOV,aAGbQ,EAAME,OAAOR,gBAKzBE,EAAUO,QAAQvB,GAClBgB,EAAUO,QAAQlB","file":"scrollAction.245400c5.js","sourceRoot":"../../src","sourcesContent":["// \n// Анимация движения овала в секции Video при скроллинге страницы и нахождении секции Video в области видимости\n// \n\nif (window.innerWidth > 1024) {\n    const vid = document.getElementById('video');\n    const voval = document.querySelector('.video__oval-cont');\n    \n    // добавляем движения второго овала в секции с видео Youtube.\n    //  const vid2 надо объявлять до observer2.observe(vid2); - иначе не работает\n    \n    const vid2 = document.getElementById('video2');\n    const vovalYtb = document.getElementById('video__oval-cont_ytb');\n    \n    // Каждой отдельной секции пишем свою функцию и создаём отдельный листнер - чтобы они не мешали друг другу перекрёстно. Всё это добавляем в метод секции и вызываем циклом (у разных секций создаём  одинаковые имена методов, но разное содержание методов).\n    \n    function moveOval1() {\n        if (window.innerWidth < 1024) {\n            voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (27 - (window.scrollY * 0.01)) + 'rem)';\n        } else {\n            voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (20 - (window.scrollY * 0.01)) + 'rem)';\n        }\n    };\n    vid.scrllstart = () => {\n        document.addEventListener('scroll', moveOval1);\n    };\n    vid.scrllstop = () => {\n        document.removeEventListener('scroll', moveOval1);\n        // console.log('listener 1 removed');\n    };\n    \n    function moveOval2() {\n        if (window.innerWidth < 1024) {\n            vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (37 - (window.scrollY * 0.01)) + 'rem)';\n        } else {\n            vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (35 - (window.scrollY * 0.01)) + 'rem)';\n        }\n    };\n    vid2.scrllstart = () => {\n        document.addEventListener('scroll', moveOval2);\n    };\n    vid2.scrllstop = () => {\n        document.removeEventListener('scroll', moveOval2);\n        // console.log('listener 2 removed');\n    };\n    \n    const observer5 = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n            if (entry.isIntersecting === true) {\n                entry.target.scrllstart();\n                // console.log(entry);\n            } else {\n                entry.target.scrllstop();\n            }\n        })\n    })\n    \n    observer5.observe(vid);\n    observer5.observe(vid2);\n}\n\n\n\n\n\n// .onscroll -  можно применять только если один элемент - есди несколько нужноы индивидуальные листнеры\n// const observer2 = new IntersectionObserver((entries) => {\n//     entries.forEach((entry) => {\n//         if (entry.isIntersecting) {\n//             // voval.style.background = 'red';\n//             document.onscroll = (event) => {\n//                 if (window.innerWidth < 1024) {\n//                     voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (27 - (window.scrollY * 0.01)) + 'rem)';\n//                     // двигаем оба овала  - чтобы двигать по одному надо делать методы у entry с одинаковым названием но разным содержанием и запускать циклом выполнение этих методов при попадании entry в область видимости.\n//                     vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (37 - (window.scrollY * 0.01)) + 'rem)';\n//                 } else {\n//                     voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (20 - (window.scrollY * 0.01)) + 'rem)';\n//                     vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (35 - (window.scrollY * 0.01)) + 'rem)';\n//                     // console.log(entry.target);\n//                 }\n//             }\n//         }\n//         else {\n//             // убираем действие по событию .onscroll. возможно лучше всё-таки через removeEventListener (addEventListener c { once: true } - не подойдёт т.к. мы должны постоянно следить за событием scroll)\n//             // document.onscroll = void(0);\n//             document.onscroll = null;\n\n//             // !! т.к. мы используем метод document.onscroll - чтобы его можно было убрать при уходе entry из поля видимости - при доюалвении 2-х entry в observer2.observe -  глюк на больших экранах, когда видны оба блока (из-за document.onscroll = null; при уходе из видимости).\n//         }\n//     }\n//     )\n// }\n// )\n\n// observer2.observe(vid);\n// observer2.observe(vid2);"]}