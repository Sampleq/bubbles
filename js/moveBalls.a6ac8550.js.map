{"version":3,"sources":["scripts/moveBalls.js"],"names":["window","innerWidth","mbId","video","document","getElementById","vballs","querySelectorAll","moveOnce","arr","x","y","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","style","transform","Math","random","err","e","f","moveBalls","section","setInterval","addEventListener","stopBalls","once","clearInterval","_step2","_iterator2","_loop","el","transition","setTimeout","video2","vballsYtb"],"mappings":"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","file":"moveBalls.a6ac8550.js","sourceRoot":"../../../src","sourcesContent":["// \n// Анимация движения шаров для секции Video - при наведении на неё указателя мыши\n// \nif (window.innerWidth >= 1024) {\n\n    const video = document.getElementById('video');\n    const vballs = document.querySelectorAll('.video__ball');\n\n    // задаём функцию для передвижения объектов массива на заданное расстояние (в rem)\n    // Math.floor() для округления до меньшего целого - можно не использовать\n    function moveOnce(arr, x, y) {\n        for (let el of arr) {\n            el.style.transform = 'translate(' + (Math.random() * (2 * x) - x) + 'rem, ' + (Math.random() * (2 * y) - y) + 'rem) ' + 'scale(' + (0.4 + Math.random() * 1.1) + ')';\n        }\n    }\n\n    // задаём переменную в которую будем сохранять \"идентификатор для регулярного запуска функции\" moveBalls - идентификатор возвращает функция setInterval() -, чтобы потом можно было остановить её повторяющееся выполнение через clearInterval(). При вызове clearInterval() браузер найдёт таймер (из список активных таймеров браузера) по идентификатору и уберёт его из списка - повторение функции moveBalls прекратится.\n    let mbId;\n\n    // Создаём функцию с однократным запуском перемещения элементов и регулярным её перезапуском каждые 4000мс\n    function moveBalls(section, arr, x, y) {\n        moveOnce(arr, x, y);\n        mbId = setInterval(moveOnce, 4000, arr, x, y);\n\n        // вешаем листнер на остановку анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится. ({ once: true } можно даже использовать с анонимными функциями и не нужно будет очищать обработчик  - он удалится автоматически.)\n        section.addEventListener('mouseleave', () => { stopBalls(section, arr) }, { once: true });\n    }\n\n    // Создаём функцию, которая остановит регулярный перезапуск moveOnce. - Функции clearInterval() передаём аргументом идентификатор регулярного перезапуска функции - идентификатором, который возвращает функция setInterval() - мы его сохранили в переменную mbId\n    function stopBalls(section, arr) {\n        // прервали повторение выполнения функции перемещения элементов moveOnce\n        clearInterval(mbId);\n\n        for (let el of arr) {\n            //  зададём продолжительность transition 0.5s для  элементов - чтобы плавно но быстро вернуть их в начальное место.\n            el.style.transition = 'all 0.5s linear';\n\n            //  для каждой ширины экрана возвращаем начальные свойства transform  для элементов\n            if (window.innerWidth < 425) {\n                el.style.transform = 'translate(0, 0) scale(0.35)';\n            } else {\n                if (window.innerWidth < 768) {\n                    el.style.transform = 'translate(0, 0) scale(0.5)';\n                } else {\n                    if (window.innerWidth < 1024) {\n                        el.style.transform = 'translate(0, 0) scale(0.75)';\n                    } else {\n                        el.style.transform = 'translate(0, 0)';\n                    }\n                }\n            }\n            // после выполнения остального js кода - возвращаем изначальное значение transition = 12s для всех элементов - чтоб при следующих запусках перемещений элементы двигались с изначально заданной скоростью.\n            //  Хотя transition =  12s присваивается элементам ещё в момент анимации с transition = 0.5s  - анимация всё равно продолжается время 0.5s - как это было указано во время начала анимации\n            setTimeout(\n                () => {\n                    el.style.transition = 'all 12s linear';\n                }\n                , 16)\n        }\n\n        // вешаем листнер на старт анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится.\n        section.addEventListener('mouseenter', () => { moveBalls(section, arr, 80, 40) }, { once: true });\n    }\n\n    // вешаем первоначальный (после загрузки страницы) листнер на старт анимации. Благодаря опции  { once: true }  - обработчик сработает один раз, а затем автоматически удалится. (убрать листнер  с функцией с аргументами  через removeEventListener - не получается, внутрь безымянной функции-обёртки класть не стал)\n    video.addEventListener('mouseenter', () => { moveBalls(video, vballs, 80, 40) }, { once: true });\n\n    // не экономя память - просто вешаем листнеры\n    // video.addEventListener('mouseenter', () => { moveBalls(vballs, 80, 40) });\n    // вешаем листнер для остановки анимации.\n    // video.addEventListener('mouseleave', () => { stopBalls(vballs) });\n\n    // добавляем анимацию на второй блок с видео с id=\"video2\"\n\n    const video2 = document.getElementById('video2');\n    const vballsYtb = document.querySelectorAll('.video__ball_ytb');\n\n    video2.addEventListener('mouseenter', () => { moveBalls(video2, vballsYtb, 80, 40) }, { once: true })\n\n}"]}