{"version":3,"sources":["scripts/scrollAction.js"],"names":["vid","document","getElementById","voval","querySelector","vid2","vovalYtb","moveOval1","window","innerWidth","style","transform","scrollY","moveOval2","scrllstart","addEventListener","scrllstop","removeEventListener","console","log","observer5","IntersectionObserver","entries","forEach","entry","isIntersecting","target","observe"],"mappings":";AAKA,IAAMA,EAAMC,SAASC,eAAe,SAE9BC,EAAQF,SAASG,cAAc,qBAkC/BC,EAAOJ,SAASC,eAAe,UAO/BI,EAAWL,SAASC,eAAe,wBAIzC,SAASK,IACDC,OAAOC,WAAa,KACpBN,EAAMO,MAAMC,UAAY,cAAwC,IAAjBH,OAAOI,QAAZ,IAA+B,QAAU,GAAuB,IAAjBJ,OAAOI,SAAmB,OAEnHT,EAAMO,MAAMC,UAAY,cAAwC,IAAjBH,OAAOI,QAAZ,IAA+B,QAAU,GAAuB,IAAjBJ,OAAOI,SAAmB,OAY3H,SAASC,IACDL,OAAOC,WAAa,KACpBH,EAASI,MAAMC,UAAY,cAAyC,IAAjBH,OAAOI,QAAb,KAAgC,QAAU,GAAuB,IAAjBJ,OAAOI,SAAmB,OAEvHN,EAASI,MAAMC,UAAY,cAAyC,IAAjBH,OAAOI,QAAb,KAAgC,QAAU,GAAuB,IAAjBJ,OAAOI,SAAmB,OAb/HZ,EAAIc,WAAa,WACbb,SAASc,iBAAiB,SAAUR,IAExCP,EAAIgB,UAAY,WACZf,SAASgB,oBAAoB,SAAUV,GACvCW,QAAQC,IAAI,uBAWhBd,EAAKS,WAAa,WACdb,SAASc,iBAAiB,SAAUF,IAExCR,EAAKW,UAAY,WACbf,SAASgB,oBAAoB,SAAUJ,GACvCK,QAAQC,IAAI,uBAGhB,IAAMC,EAAY,IAAIC,qBAAqB,SAACC,GACxCA,EAAQC,QAAQ,SAACC,IACgB,IAAzBA,EAAMC,eACND,EAAME,OAAOZ,aAGbU,EAAME,OAAOV,gBAKzBI,EAAUO,QAAQ3B,GAClBoB,EAAUO,QAAQtB","file":"scrollAction.900d01a6.js","sourceRoot":"../../../src","sourcesContent":["// \n// Анимация движения овала в секции Video при скроллинге страницы и нахождении секции Video в области видимости\n// \n\n\nconst vid = document.getElementById('video');\n\nconst voval = document.querySelector('.video__oval-cont');\n\n// .onscroll -  можно применять только если один элемент - есди несколько нужноы индивидуальные листнеры\n// const observer2 = new IntersectionObserver((entries) => {\n//     entries.forEach((entry) => {\n//         if (entry.isIntersecting) {\n//             // voval.style.background = 'red';\n//             document.onscroll = (event) => {\n//                 if (window.innerWidth < 1024) {\n//                     voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (27 - (window.scrollY * 0.01)) + 'rem)';\n//                     // двигаем оба овала  - чтобы двигать по одному надо делать методы у entry с одинаковым названием но разным содержанием и запускать циклом выполнение этих методов при попадании entry в область видимости.\n//                     vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (37 - (window.scrollY * 0.01)) + 'rem)';\n//                 } else {\n//                     voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (20 - (window.scrollY * 0.01)) + 'rem)';\n//                     vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (35 - (window.scrollY * 0.01)) + 'rem)';\n//                     // console.log(entry.target);\n//                 }\n//             }\n//         }\n//         else {\n//             // убираем действие по событию .onscroll. возможно лучше всё-таки через removeEventListener (addEventListener c { once: true } - не подойдёт т.к. мы должны постоянно следить за событием scroll)\n//             // document.onscroll = void(0);\n//             document.onscroll = null;\n\n//             // !! т.к. мы используем метод document.onscroll - чтобы его можно было убрать при уходе entry из поля видимости - при доюалвении 2-х entry в observer2.observe -  глюк на больших экранах, когда видны оба блока (из-за document.onscroll = null; при уходе из видимости).\n//         }\n//     }\n//     )\n// }\n// )\n\n// добавляем движения второго овала в секции с видео Youtube.\n//  const vid2 надо объявлять до observer2.observe(vid2); - иначе не работает\n\nconst vid2 = document.getElementById('video2');\n\n// observer2.observe(vid);\n// observer2.observe(vid2);\n\n\n\nconst vovalYtb = document.getElementById('video__oval-cont_ytb');\n\n// Каждой отдельной секции пишем свою функцию и создаём отдельный листнер - чтобы они не мешали друг другу перекрёстно. Всё это добавляем в метод секции и вызываем циклом (у разных секций создаём  одинаковые имена методов, но разное содержание методов).\n\nfunction moveOval1 () {\n    if (window.innerWidth < 1024) {\n        voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (27 - (window.scrollY * 0.01)) + 'rem)';\n    } else {\n        voval.style.transform = 'translate(' + ((-85 + window.scrollY * 0.03)) + 'rem,' + (20 - (window.scrollY * 0.01)) + 'rem)';\n    }\n} ;\nvid.scrllstart = ()=> {\n    document.addEventListener('scroll', moveOval1);\n};\nvid.scrllstop = ()=> {\n    document.removeEventListener('scroll', moveOval1);\n    console.log('listener 1 removed');\n};\n\n\nfunction moveOval2 () {\n    if (window.innerWidth < 1024) {\n        vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (37 - (window.scrollY * 0.01)) + 'rem)';\n    } else {\n        vovalYtb.style.transform = 'translate(' + ((-125 + window.scrollY * 0.03)) + 'rem,' + (35 - (window.scrollY * 0.01)) + 'rem)';\n    }\n}\nvid2.scrllstart = ()=> {\n    document.addEventListener('scroll', moveOval2);\n};\nvid2.scrllstop = ()=> {\n    document.removeEventListener('scroll', moveOval2);\n    console.log('listener 2 removed');\n};\n\nconst observer5 = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n        if (entry.isIntersecting === true) {\n            entry.target.scrllstart();\n            // console.log(entry);\n        } else {\n            entry.target.scrllstop();\n        }\n    })\n})\n\nobserver5.observe(vid);\nobserver5.observe(vid2);"]}